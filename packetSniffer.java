import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;  
import java.util.Date;  
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;  
  




import java.util.Map;

import javax.swing.SwingUtilities;

import org.jfree.ui.RefineryUtilities;
import org.jnetpcap.Pcap;  
import org.jnetpcap.PcapBpfProgram;
import org.jnetpcap.PcapIf;  
import org.jnetpcap.nio.JMemory;
import org.jnetpcap.packet.JFlow;
import org.jnetpcap.packet.JFlowKey;
import org.jnetpcap.packet.JPacket;
import org.jnetpcap.packet.JScanner;
import org.jnetpcap.packet.PcapPacket;  
import org.jnetpcap.packet.PcapPacketHandler;  
import org.jnetpcap.packet.format.FormatUtils;
import org.jnetpcap.protocol.network.Ip4;
import org.jnetpcap.protocol.tcpip.Tcp;
import org.jnetpcap.protocol.tcpip.Udp;
  
/** 
 * Here is the output generated by this example : 
 *  
 *  Network devices found: 
 *  #0: \Device\NPF_{BC81C4FC-242F-4F1C-9DAD-EA9523CC992D} [Intel(R) PRO/100 VE]  
 *  #1: \Device\NPF_{E048DA7F-D007-4EEF-909D-4238F6344971} [VMware Virtual Ethernet Adapter] 
 *  #2: \Device\NPF_{5B62B373-3EC1-460D-8C71-54AA0BF761C7} [VMware Virtual Ethernet Adapter] 
 *  #3: \Device\NPF_GenericDialupAdapter [Adapter for generic dialup and VPN capture] 
 *  
 *  Choosing 'Intel(R) PRO/100 VE) ' on your behalf: 
 *  Received packet at Tue Nov 03 18:52:42 EST 2009 caplen=1362 len=1362 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=82   len=82   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=145  len=145  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=164  len=164  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=54   len=54   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1073 len=1073 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1514 len=1514 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=279  len=279  jNetPcap rocks! 
 */  
public class packetSniffer {  
  
    /** 
     * Main startup method 
     *  
     * @param args 
     *          ignored 
     */  
	public static int packetAmount = Pcap.LOOP_INFINITE;//10;//
	private static int i2 = 1;
	private static int lastValue1;					//For the tcp line
	private static int lastValue1_2;				//For the udp line
	private static LinkedList<Integer> tcpSizeVariables = new LinkedList<Integer>(); // inbound packets
	private static LinkedList<Integer> udpSizeVariables = new LinkedList<Integer>();
	private static LinkedList<Integer> tcpSizeVariables2 = new LinkedList<Integer>(); // outbound packets
	private static LinkedList<Integer> udpSizeVariables2 = new LinkedList<Integer>();
	private static HashMap<String,Integer> ipTable = new HashMap<String,Integer>(); // the match up is the ip address and the index of the ip address in the tcpSizeVariables and udpSizeVariables.
	private static LinkedList<String> ipList = new LinkedList<String>();
	public static int portAddress = 1111;
	private static int playerSize;
	
	static int i=0;
    public static void main(String[] args) { 
    	System.out.println("Started.");
    	playerSize = getPlayerSize();
    	initializeLinkedLists();
    	ipTable = convertHashSet();
    	System.out.println(ipTable);
    	final packetInfoWindow demo = new packetInfoWindow();
        RefineryUtilities.centerFrameOnScreen(demo);
        demo.setVisible(true);
    	
        List<PcapIf> alldevs = new ArrayList<PcapIf>(); // Will be filled with NICs  
        StringBuilder errbuf = new StringBuilder(); // For any error msgs  
        
        /*************************************************************************** 
         * First get a list of devices on this system 
         **************************************************************************/  
        int r = Pcap.findAllDevs(alldevs, errbuf);  
        if (r == Pcap.NOT_OK || alldevs.isEmpty()) {  
            System.err.printf("Can't read list of devices, error is %s", errbuf  
                .toString());  
            return;  
        }  
  
        System.out.println("Network devices found:");  
  
        int i = 0;  
        for (PcapIf device : alldevs) {  
            String description =  
                (device.getDescription() != null) ? device.getDescription()  
                    : "No description available";  
            System.out.printf("#%d: %s [%s]\n", i++, device.getName(), description);  
        }  
  
        PcapIf device = alldevs.get(0); // We know we have atleast 1 device  
        System.out  
            .printf("\nChoosing '%s' on your behalf:\n",  
                (device.getDescription() != null) ? device.getDescription()  
                    : device.getName());  
  
        /*************************************************************************** 
         * Second we open up the selected device 
         **************************************************************************/  
        int snaplen = 64 * 1024;           // Capture all packets, no trucation  
        int flags = Pcap.MODE_PROMISCUOUS; // capture all packets  
        int timeout = 1;           // 1/1000 of a second. Use a low amount for real time gathering of packets.  
        Pcap pcap =  
            Pcap.openLive(device.getName(), snaplen, flags, timeout, errbuf);  
  
        if (pcap == null) {  
            System.err.printf("Error while opening device for capture: "  
                + errbuf.toString());  
            return;  
        }  
  
        /*************************************************************************** 
         * Third we create a packet handler which will receive packets from the 
         * libpcap loop. 
         **************************************************************************/  
        
        PcapPacketHandler<String> jpacketHandler = new PcapPacketHandler<String>() {  
        	
            public void nextPacket(PcapPacket packet, String user) {  
            	Tcp tcp = new Tcp();
            	Ip4 ip = new Ip4();
            	Udp udp = new Udp();
            	int tcpSizeIn = 0;
            	int tcpSizeOut = 0;
            	int udpSizeIn = 0;
            	int udpSizeOut = 0;
            	String sourceIp;
            	String destIp;
            	if(packet.hasHeader(ip) == true){
            		sourceIp = FormatUtils.ip(ip.source());
        			destIp = FormatUtils.ip(ip.destination());
            		
            		if(packet.hasHeader(tcp) == true){
            			
            			if(tcp.destination() == 1111){ //inbound packets
	        				System.out.println("----------------------------------------------");
	            			System.out.println("*** Packet " + ++packetSniffer.i + " :");
	            			System.out.println("Source Ip : " + sourceIp);
	    					System.out.println("Destination Ip : " + destIp);
	            			System.out.println("Source Port : " + tcp.source());
	            			System.out.println("Destination Port : " + tcp.destination());
	            			System.out.println("----------------------------------------------");
	            			tcpSizeIn = packet.getPacketWirelen();
	            			System.out.println("Size : " + tcpSizeIn);
	            			//tcpSizeIn -= 66;
	            			//tcpSizeVariables.set(ipTable.get(sourceIp),tcpSizeIn);
	            		}
	            		
	            		if(tcp.source() == 1111){ //outbound packets
	            			System.out.println("----------------------------------------------");
	            			System.out.println("*** Packet " + ++packetSniffer.i + " :");
	            			System.out.println("Source Ip : " + sourceIp);
	    					System.out.println("Destination Ip : " + destIp);
	            			System.out.println("Source Port : " + tcp.source());
	            			System.out.println("Destination Port : " + tcp.destination());
	            			System.out.println("----------------------------------------------");
	            			tcpSizeOut = packet.getPacketWirelen();
	            			System.out.println("Size : " + tcpSizeOut);
	            			//tcpSizeOut -= 66;
	            			//tcpSizeVariables2.set(ipTable.get(sourceIp),tcpSizeIn);
	            		}
	            		
            		}
            		
            		if(packet.hasHeader(udp) == true){
	            		if(udp.destination() == 1111){ //inbound packets
	            			System.out.println("----------------------------------------------");
	            			System.out.println("*** Packet " + ++packetSniffer.i + " :");
	            			System.out.println("Source Ip : " + sourceIp);
	    					System.out.println("Destination Ip : " + destIp);
	            			System.out.println("Source Port : " + udp.source());
	            			System.out.println("Destination Port : " + udp.destination());
	            			System.out.println("----------------------------------------------");
	            			udpSizeIn = packet.getPacketWirelen();
	            			System.out.println("Size : " + udpSizeIn);
	            			//udpSizeIn -= 66;
	            			//udpSizeVariables.set(ipTable.get(sourceIp),tcpSizeIn);
	            		}
	            		
	            		if(udp.source() == 1111){ //outbound packets
	            			System.out.println("----------------------------------------------");
	            			System.out.println("*** Packet " + ++packetSniffer.i + " :");
	            			System.out.println("Source Ip : " + sourceIp);
	    					System.out.println("Destination Ip : " + destIp);
	            			System.out.println("Source Port : " + udp.source());
	            			System.out.println("Destination Port : " + udp.destination());
	            			System.out.println("----------------------------------------------");
	            			udpSizeOut = packet.getPacketWirelen();
	            			System.out.println("Size : " + udpSizeOut);
	            			//udpSizeOut -= 66;
	            			//udpSizeVariables2.set(ipTable.get(sourceIp),tcpSizeIn);
	            		}
            		}
            		
            		lastValue1 = tcpSizeIn + udpSizeIn;
            		lastValue1_2 = tcpSizeOut + udpSizeOut;
            	}
            }  
        };  
        pcap.loop(packetAmount, jpacketHandler, "Read packet.");  
  
        
        pcap.close();  
        
        
    }  
    
    public static HashMap<String,Integer> convertHashSet(){
    	 byte [] data = "AskIpList".getBytes() ;
    	 String serverAddress = TCPClient.getServAdd();
    	 InetAddress host;
    	 int returnValue = 0;
    	 HashMap<String,Integer> toReturn = new HashMap<String,Integer>();
    	 try {
 			host = InetAddress.getByName( serverAddress );
 			DatagramSocket socketUDP = new DatagramSocket(); 
 			DatagramPacket packet = new DatagramPacket( data, data.length, host, portAddress ) ;
 			// Send it
             socketUDP.send( packet ) ;
           //Create packet for response
             byte[] receivedData = new byte[1024];
             DatagramPacket receivePacket = new DatagramPacket(receivedData,receivedData.length);
             
             // Wait for a response from the server
             socketUDP.receive( receivePacket ) ;
           //decode the ip addresses
             String listOfAddresses = new String(receivePacket.getData());
             listOfAddresses = String.valueOf(listOfAddresses);
             System.out.println(listOfAddresses);
             listOfAddresses = listOfAddresses.substring(1, listOfAddresses.length()-(1024-listOfAddresses.lastIndexOf(']')));
             String[] listOfAdds = listOfAddresses.split(",");
             for(int i=0;i<listOfAdds.length;i++){
            	 listOfAdds[i].replaceAll("\\s+","");
            	 toReturn.put(listOfAdds[i],i);
            	 ipList.add(listOfAdds[i]);
             }
            	 
    	 }catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
    	 return toReturn;
    }
    
    public static void initializeLinkedLists(){
    	for(int i=0;i<playerSize;i++){
    		tcpSizeVariables.add(0);
    		udpSizeVariables.add(0);
    		tcpSizeVariables2.add(0);
    		udpSizeVariables2.add(0);
    	}
    }
    
    public static double getPacketSizeOfIndex(int i,String mode){
    	if(mode.equals("tcp"))
    		return (double)tcpSizeVariables.get(i);
    	if(mode.equals("udp"))
    		return (double)udpSizeVariables.get(i);
    	if(mode.equals("tcp2"))
    		return (double)tcpSizeVariables2.get(i);
    	if(mode.equals("udp2"))
    		return (double)udpSizeVariables2.get(i);
    	return 0;
    }
    
    public static int getLastValue(int number){
    	switch(number){
    		case 1:
    			return lastValue1;
    		case 2:
    			return lastValue1_2;
    	}
    	
    	return 0;
    }
    
    public static int getPlayerSize(){
    	 byte [] data = "AskPlayerSize".getBytes() ;
    	 String serverAddress = TCPClient.getServAdd();
    	 InetAddress host;
    	 int returnValue = 0;
    	 
		try {
			host = InetAddress.getByName( serverAddress );
			DatagramSocket socketUDP = new DatagramSocket(); 
			DatagramPacket packet = new DatagramPacket( data, data.length, host, portAddress ) ;
			// Send it
            socketUDP.send( packet ) ;
             
            //Create packet for response
            byte[] receivedData = new byte[1024];
            DatagramPacket receivePacket = new DatagramPacket(receivedData,receivedData.length);
            
            // Wait for a response from the server
            socketUDP.receive( receivePacket ) ;
           //decode the usernames
            String sizeInString = new String(receivePacket.getData());
            sizeInString = sizeInString.trim();
            System.out.println("size : " + sizeInString);
            return Integer.parseInt(sizeInString);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return returnValue;
        
    }
    
    public static String[] getIpArray(){
    	String[] array = ipList.toArray(new String[ipList.size()]);
    	
    	return array;
    }
    
}  